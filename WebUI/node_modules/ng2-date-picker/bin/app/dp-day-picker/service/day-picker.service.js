"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var calendar_service_1 = require('./../../dp-calendar/config/calendar.service');
var core_1 = require('@angular/core');
var moment = require('moment');
var utils_service_1 = require('../../common/services/utils/utils.service');
var DayPickerService = (function () {
    function DayPickerService(calendarContainerService) {
        this.calendarContainerService = calendarContainerService;
        this.defaultConfig = {
            closeOnSelect: true,
            closeOnSelectDelay: 100,
            disableKeypress: false,
            drops: 'down',
            opens: 'right'
        };
    }
    DayPickerService.prototype.getConfig = function (config) {
        var _config = Object.assign({}, this.defaultConfig, config);
        if (config && config.allowMultiSelect && config.closeOnSelect === undefined) {
            _config.closeOnSelect = false;
        }
        return this.calendarContainerService.getConfig(_config);
    };
    DayPickerService.prototype.isDateValid = function (date, format) {
        if (date === '') {
            return true;
        }
        return moment(date, format, true).isValid();
    };
    DayPickerService.prototype.createValidator = function (_a, dateFormat) {
        var minDate = _a.minDate, maxDate = _a.maxDate;
        var isValid;
        var value;
        var validators = [];
        if (minDate) {
            validators.push({
                key: 'minDate',
                isValid: function () {
                    var _isValid = value.every(function (val) { return val.isSameOrAfter(minDate, 'day'); });
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        if (maxDate) {
            validators.push({
                key: 'maxDate',
                isValid: function () {
                    var _isValid = value.every(function (val) { return val.isSameOrBefore(maxDate, 'day'); });
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        return function validateInput(c) {
            var _this = this;
            isValid = true;
            if (c.value) {
                if (typeof c.value === 'string') {
                    var dateStrings = c.value.split(',').map(function (date) { return date.trim(); });
                    var validDateStrings = dateStrings.filter(function (date) { return _this.dayPickerService.isDateValid(date, _this.pickerConfig.format); });
                    value = validDateStrings.map(function (dateString) { return moment(dateString, dateFormat); });
                }
                else if (!Array.isArray(c.value)) {
                    value = [c.value];
                }
                else {
                    value = c.value.map(function (val) { return utils_service_1.UtilsService.convertToMoment(val, dateFormat); });
                }
            }
            else {
                return null;
            }
            if (!value.every(function (val) { return val.isValid(); })) {
                return {
                    format: {
                        given: c.value
                    }
                };
            }
            var errors = validators.reduce(function (map, err) {
                if (!err.isValid()) {
                    map[err.key] = {
                        given: value
                    };
                }
                return map;
            }, {});
            return !isValid ? errors : null;
        };
    };
    DayPickerService = __decorate([
        core_1.Injectable(), 
        __metadata('design:paramtypes', [calendar_service_1.CalendarService])
    ], DayPickerService);
    return DayPickerService;
}());
exports.DayPickerService = DayPickerService;

//# sourceMappingURL=day-picker.service.js.map
